/*by ernestzhang 2014-11-06*/
'use strict';
var net = require('net');
var fs  = require('fs');
var events = require('events');

var client = {
	HEAD_PKG_SIZE:10 ,
	BODY_LEN_SIZE:8,
	GROUP_NAME_LEN:16,
	IP_ADDR_LEN:15,
	PORT_LEN:8 ,
	PKG_LEN_SIZE:8 , //协议里所有的长度都用8bytes标识
	FDFS_FILE_EXT_NAME_MAX_LEN:6 , //后缀名长度
	protocol: {
		TRACKER_PROTO_CMD_SERVICE_QUERY_STORE_WITHOUT_GROUP_ONE: 101,
		TRACKER_PROTO_CMD_SERVICE_QUERY_STORE_WITHOUT_GROUP_ONE_RSP:100,
		STORAGE_PROTO_CMD_UPLOAD_FILE:11 ,
		STORAGE_PROTO_CMD_UPLOAD_FILE_RSP:100 ,
		STORAGE_PROTO_CMD_DOWNLOAD_FILE:14,
		STORAGE_PROTO_CMD_DELETE_FILE:12
	},
	storage_info:{

	},
	sock:{

	},
	header:{

	}
};

client.closeSock = function(){

		client.resetSockCtx();
		if(client.sock) {
			client.sock.isConnectStorage = false ;
			client.sock.end();
			client.sock.destroy();
			client.sock = null ;
		}
};

client.resetSockCtx = function()
{
	client.header = {} ;
	if(client.sock) {
		client.sock.recvbuf = null ;
		client.sock.recvlen = 0 ;
	}
}

client.parseError = function (rspCmd , status) {
	if(rspCmd == client.protocol.STORAGE_PROTO_CMD_DOWNLOAD_FILE && status == 2)
		  return  "file is not exist" ;
	else
		  return  "another error"

}

/*解析协议头部*/
client.parseCore = function(data ,callback){ //解析头部

		var flag = 0 ;
        if(!client.sock.recvbuf)//没有分配过缓冲区
        {
            client.sock.recvbuf = Buffer.concat([data] , data.length);
			flag = 1;
			//console.log("first recv:%d" , data.length);
        }
		else
		{
			//如果是文件下载,且协议头已经分析完毕(strCmd字段可表明)，则直接触发回调
			if(client.header.srcCmd == client.protocol.STORAGE_PROTO_CMD_DOWNLOAD_FILE)
			{
				var dlinfo = {} ;
				dlinfo.data = data ;
				client.sock.recvlen += data.length ;//当为下载协议时，recvlen和 recvbuf.length就会不一致，recvlen仅仅表示曾经收到过的字节数
				if(client.sock.recvlen < client.HEAD_PKG_SIZE + client.header.bodyLen)
					dlinfo.end = false ;
				else
					dlinfo.end = true ;
				callback(null , dlinfo);
				return ;
			}
			else
				client.sock.recvbuf = Buffer.concat([client.sock.recvbuf , data] ,client.sock.recvlen+data.length);
		}
	    client.sock.recvlen += data.length ;


        var curlen = client.sock.recvlen;
        if (curlen >= client.HEAD_PKG_SIZE) //收到的长度大于头部,则解析头部长度,否则继续收数据
        {
			if(client.header.rspCmd === undefined ) {
				var bodylen = client.sock.recvbuf.readUInt32BE(4);//针对FDFS的协议特殊处理
				client.header.bodyLen = bodylen;
				client.header.rspCmd = client.sock.recvbuf.readUInt8(client.HEAD_PKG_SIZE - 2);
				client.header.status = client.sock.recvbuf.readUInt8(client.HEAD_PKG_SIZE - 1);
				//console.log("header cmd: %d bodylen:%d status:%d" ,  client.header.srcCmd , client.header.bodyLen ,client.header.status);
				if(client.header.status != 0)//操作失败
				{
					callback("操作失败,协议号:" + client.header.srcCmd+" 错误:" + client.parseError(client.header.srcCmd , client.header.status));
					client.resetSockCtx();
					return ;
				}
			}

            if (curlen >= (client.header.bodyLen + client.HEAD_PKG_SIZE))//已经有完整的包
            {

                    var func = 'P'+client.header.srcCmd ;
					//console.log("src cmd.....:%s" , func);
                    if(client[func] == undefined || typeof client[func] != 'function'){
                         client.closeSock();
                         callback("cmd is not defined:" + func) ;
                    }
                    else
                    {
						 client[func](callback);
                    }
            }
			else
			{
				//如果是下载文件,直接触发回调
				if(client.header.srcCmd == client.protocol.STORAGE_PROTO_CMD_DOWNLOAD_FILE)
				{
					var dlinfo = {};
					dlinfo.end  = false ;
					if(flag == 1)//data数据里还包含了文件之外的数据，跳过...
					{
						dlinfo.data = data.slice(client.HEAD_PKG_SIZE, client.sock.recvbuf.length) ;
						callback(null, dlinfo);
					}
					else
					{
						dlinfo.data = data ;
						callback(null,dlinfo);
					}

				}
			}

        }
};

//获取storage 服务器的IP和端口---回包
client.P101 = function(callback){

    //解析包体
    var pos =  client.HEAD_PKG_SIZE ;
    var group_name = client.sock.recvbuf.slice(pos , pos + client.GROUP_NAME_LEN).toString('ascii');
        pos += client.GROUP_NAME_LEN ;
    var storage_ip =  client.sock.recvbuf.slice(pos , pos + client.IP_ADDR_LEN).toString('ascii');
        pos += client.IP_ADDR_LEN ;
    var storage_port = client.sock.recvbuf.slice(pos  , pos + client.PORT_LEN).readUInt32BE(4);
        pos += client.PORT_LEN ;
    var path  = client.sock.recvbuf[pos];
        pos += 1 ;

    //关闭连接
    client.closeSock();

	//设置返回值
    client.storage_info ={};
    client.storage_info.host = storage_ip ;
    client.storage_info.port = storage_port ;
    client.storage_info.path = path ;
    client.storage_info.group_name = group_name ;

    callback(null , client.storage_info);
};

//删除文件---回包
client.P12 = function(callback)
{
	 callback(null);
}

//上传文件----回包
client.P11 = function(callback){

    //解析包体
    var pos =  client.HEAD_PKG_SIZE ;
    var group_name = client.sock.recvbuf.slice(pos , pos + client.GROUP_NAME_LEN).toString('ascii');
    pos += client.GROUP_NAME_LEN ;



    var file_name = client.sock.recvbuf.slice(pos , client.header.bodyLen + client.HEAD_PKG_SIZE).toString('ascii');


    //保存结果
    client.storage_info.group_name = group_name ;
    client.storage_info.file_name =  file_name ;

    //清空内存
	client.resetSockCtx();
	//console.log("++++++++++");
	//console.log(client.storage_info);
	//console.log("---------");
    callback(null , client.storage_info);

};

client.P14 = function(callback){
	//解析包体
	var dlinfo = {} ;
	dlinfo.end = true ;
	dlinfo.data = client.sock.recvbuf.slice(client.HEAD_PKG_SIZE  , client.sock.recvbuf.length);
	callback(null , dlinfo);
	//清空内存
	client.resetSockCtx() ;
};

client.sendRequest2TrackerSvr = function () {

	var header = new  Buffer(client.HEAD_PKG_SIZE);
	header.fill(0 , 0 ,  client.BODY_LEN_SIZE);
	header[client.HEAD_PKG_SIZE-2] = client.protocol.TRACKER_PROTO_CMD_SERVICE_QUERY_STORE_WITHOUT_GROUP_ONE ;
	header[client.HEAD_PKG_SIZE-1] = 0 ;
	//记住之前发过的协议号
	client.header.srcCmd = client.protocol.TRACKER_PROTO_CMD_SERVICE_QUERY_STORE_WITHOUT_GROUP_ONE ;
	client.sock.write(header);
};

client.deleteFilePackage = function(args)
{
	var callback  = args[1] ;
	var groupname = args[3] ;
	var filename  = args[4] ;
	if(!groupname || !filename)
	{
		callback("group name or file name is not correct.");
	}
	else
	{
		var bodylen = client.GROUP_NAME_LEN + filename.length;
		var sendbuf = new Buffer(client.HEAD_PKG_SIZE + bodylen);

		//设置包头里的包体长度字段
		sendbuf.writeUInt32BE(0, 0);
		sendbuf.writeUInt32BE(bodylen , 4);
		sendbuf[client.HEAD_PKG_SIZE - 2] = client.protocol.STORAGE_PROTO_CMD_DELETE_FILE ;
		sendbuf[client.HEAD_PKG_SIZE - 1] = 0 ;

		//设置组名
		var pos = client.HEAD_PKG_SIZE ;
		sendbuf.fill(0 , pos , pos + client.GROUP_NAME_LEN) ;
		sendbuf.write(groupname , pos , groupname.length);
		pos += client.GROUP_NAME_LEN ;


		//设置文件名
		sendbuf.fill(0, pos, pos + filename.length);
		sendbuf.write(filename , pos, filename.length );
		pos += filename.length ;

		client.header.srcCmd = client.protocol.STORAGE_PROTO_CMD_DELETE_FILE ;
		client.sock.write(sendbuf);
	}
};



client.uploadFile2StoragePackage = function(len , ext)
{
	//组装包头,先发送除文件内容以外的信息
	var totlen = client.HEAD_PKG_SIZE + 1  + client.PKG_LEN_SIZE + client.FDFS_FILE_EXT_NAME_MAX_LEN + len;
	var sendbuf = new  Buffer(totlen - len);

	//设置包头里的包体长度字段
	sendbuf.writeUInt32BE(0 ,0);
	sendbuf.writeUInt32BE(totlen - client.HEAD_PKG_SIZE ,4);
	sendbuf[client.HEAD_PKG_SIZE-2] = client.protocol.STORAGE_PROTO_CMD_UPLOAD_FILE ;
	sendbuf[client.HEAD_PKG_SIZE-1] = 0 ;

	//组装包体
	var pos = client.HEAD_PKG_SIZE ;
	sendbuf.writeUInt8(client.storage_info.path , pos);
	pos += 1 ;  //设置storage索引


	//设置文件内容长度
	sendbuf.writeUInt32BE(0 , pos);
	sendbuf.writeUInt32BE(len ,pos+4) ;
	pos += client.PKG_LEN_SIZE ;

	//设置后缀名 ,先初始化
	sendbuf.fill(0 , pos  , pos + client.FDFS_FILE_EXT_NAME_MAX_LEN);
	sendbuf.write(ext , pos , ext.length , 'ascii') ;
	pos += client.FDFS_FILE_EXT_NAME_MAX_LEN ;


	client.sock.write(sendbuf);
	client.header.srcCmd = client.protocol.STORAGE_PROTO_CMD_UPLOAD_FILE ;
};

client.uploadFile2Storage = function(args){

	var file = args[3] ;
	var ext  = args[4] ;
	var callback = args[1] ;
	var len = 0 ;
	if(typeof file == 'string') //以本地文件的方式上传
	{
        fs.stat(file , function(err , stat){
                if(err) {
					client.closeSock();
					callback(err);
				}
                else
                {
                    var len = stat.size ;
                    if(len == 0)
                    {
                        callback("error file size");
                    }
                    else
                    {
                        //发送除文件外的全部信息
                        client.uploadFile2StoragePackage(len , ext);
                        //读取文件内容并发送
                        fs.readFile(file , function (err, chunk) {
                            if(err)
                            {
                                console.log("read file error:%s" , err);
								client.closeSock();
                                callback(err);
                            }
                            else
                            {
                                //发送文件信息
                                client.sock.write(chunk);
                            }

                        });
                    }
                }

        }) ;

	}
	else//以本地Buffer的方式上传
	{
		len = file.length;
		if(len == 0)
		{
			//console.log("error buffer");
			callback("error buffer size");
			return ;
		}
		//发送除文件外的全部数据
		client.uploadFile2StoragePackage(len , ext);
		//发送文件内容
		client.sock.write(file);

	}

};

client.downloadFilePackage = function(args){
	//组装包头,先发送除文件内容以外的信息
	var groupname = args[3] ;
	var filename  = args[4] ;
	var callback  = args[1] ;

	if(!groupname || !filename)
	{
		callback("error file name or group name");
		return ;
	}

	var totlen = client.HEAD_PKG_SIZE  + client.PKG_LEN_SIZE + client.PKG_LEN_SIZE + client.GROUP_NAME_LEN + filename.length;
	var sendbuf = new  Buffer(totlen);

	//设置包头里的包体长度字段
	sendbuf.writeUInt32BE(0 ,0);
	sendbuf.writeUInt32BE(totlen - client.HEAD_PKG_SIZE , 4);
	sendbuf[client.HEAD_PKG_SIZE-2] = client.protocol.STORAGE_PROTO_CMD_DOWNLOAD_FILE ;
	sendbuf[client.HEAD_PKG_SIZE-1] = 0 ;

	//组装包体
	var pos = client.HEAD_PKG_SIZE  ;
	//文件偏移地址,设置为0
	sendbuf.writeUInt32BE(0 , pos);
	sendbuf.writeUInt32BE(0 , pos+4);
	pos += client.PKG_LEN_SIZE ;

	//要下载的大小,设置为0是否是下载整个文件????
	sendbuf.writeUInt32BE(0 , pos);
	sendbuf.writeUInt32BE(0 , pos+4) ;
	pos += client.PKG_LEN_SIZE ;

	//设置group name
	sendbuf.fill(0 ,pos  , pos + client.GROUP_NAME_LEN);
	sendbuf.write(groupname ,pos , groupname.length) ;
	pos += client.GROUP_NAME_LEN ;

	//设置filename
	sendbuf.write(filename , pos , filename.length);
	pos += filename.length ;

	client.sock.write(sendbuf);
	client.header.srcCmd = client.protocol.STORAGE_PROTO_CMD_DOWNLOAD_FILE ;
};


client.connectSvr = function (server , callback ) {

		client.sock = net.connect(server.port, server.host  ,function(){
				client.sock.recvlen = 0;
				client.sock.recvbuf = null;
				client.sendRequest2TrackerSvr();
	   });

        client.sock.on('data', function(data) {
            client.parseCore(data , callback) ;
        });

        client.sock.on('error' , function(err){
            client.closeSock();
            callback(err);
        });

        client.sock.on('end', function() {
            console.log('client disconnected');
            client.closeSock();
            callback("server closed the connection");
        });

};

client.removeListener = function(sock , ev)
{
	if(sock)
	{
		var arrfun = sock.listeners(ev);
		arrfun.forEach(function (fun) {
				sock.removeListener(ev , fun);
		});
	}
};

client.initConn2Storage = function(client , callback , packFunc)
{
	var args = arguments ;
	if(client.isConnectStorage)
	{
		client.resetSockCtx() ;
		client[packFunc](args);
	}
	else
	{
		client.sock = net.connect(client.storage_info.port, client.storage_info.host, function () {
				client.isConnectStorage = true ;
				client.resetSockCtx() ;
				client[packFunc](args) ;
		});
	}

	client.removeListener(client.sock , 'data');
	client.sock.on('data', function(data) {
		client.parseCore(data , callback) ;
	});

	client.removeListener(client.sock , 'error');
	client.sock.on('error' , function(err){
		client.closeSock();
		callback(err);
	});

	client.removeListener(client.sock , 'end');
	client.sock.on('end', function() {
		//console.log('client disconnected');
		client.closeSock();
		callback("server closed the connection");
	});
};
client.uploadFile = function(file , ext , callback){
	client.initConn2Storage(client , callback , 'uploadFile2Storage' , file , ext );
}

client.downloadFile = function(groupname , filename ,callback){
	client.initConn2Storage(client , callback , 'downloadFilePackage' , groupname ,filename) ;
};
client.deleteFile = function(groupname ,filename , callback)
{
	client.initConn2Storage(client , callback , 'deleteFilePackage' , groupname ,filename) ;
}

client.close = client.closeSock ;
module.exports = client ;





